diff --git a/internal/agent/agentfs/readdir_windows.go b/internal/agent/agentfs/readdir_windows.go
index 568ff20..e7d8b6e 100644
--- a/internal/agent/agentfs/readdir_windows.go
+++ b/internal/agent/agentfs/readdir_windows.go
@@ -3,9 +3,8 @@
 package agentfs
 
 import (
-	"errors"
 	"os"
-	"path/filepath"
+	"sync"
 	"syscall"
 	"unsafe"
 
@@ -94,13 +93,19 @@ func fileNamePtrFull(info *FILE_FULL_DIR_INFO) *uint16 {
 	return (*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(info)) + 72))
 }
 
+const (
+	FILE_ATTRIBUTE_UNPINNED = 0x00100000
+	FILE_ATTRIBUTE_PINNED   = 0x00080000
+)
+
 const (
 	excludedAttrs = windows.FILE_ATTRIBUTE_REPARSE_POINT |
 		windows.FILE_ATTRIBUTE_DEVICE |
 		windows.FILE_ATTRIBUTE_OFFLINE |
 		windows.FILE_ATTRIBUTE_VIRTUAL |
 		windows.FILE_ATTRIBUTE_RECALL_ON_OPEN |
-		windows.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS
+		windows.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS |
+		FILE_ATTRIBUTE_UNPINNED | FILE_ATTRIBUTE_PINNED
 )
 
 // windowsAttributesToFileMode converts Windows file attributes to Go's os.FileMode
@@ -134,41 +139,13 @@ func windowsAttributesToFileMode(attrs uint32) uint32 {
 	return uint32(mode)
 }
 
-// fileIsAvailable checks if the file (or directory) at "dirPath/name" can be opened.
-// If isDir is true, FILE_FLAG_BACKUP_SEMANTICS is used.
-func fileIsAvailable(dirPath, name string, isDir bool) bool {
-	fullPath := filepath.Join(dirPath, name)
-	pFullPath, err := windows.UTF16PtrFromString(fullPath)
-	if err != nil {
-		return false
-	}
-
-	var flags uint32 = 0
-	if isDir {
-		flags = windows.FILE_FLAG_BACKUP_SEMANTICS
-	}
-
-	h, err := windows.CreateFile(
-		pFullPath,
-		windows.GENERIC_READ,
-		windows.FILE_SHARE_READ|windows.FILE_SHARE_WRITE|windows.FILE_SHARE_DELETE,
-		nil,
-		windows.OPEN_EXISTING,
-		flags,
-		0,
-	)
-	if err != nil {
-		return false
-	}
-	windows.CloseHandle(h)
-	return true
+var bufPool = sync.Pool{
+	New: func() interface{} {
+		b := make([]byte, 256*1024) // 256KB initial buffer
+		return &b
+	},
 }
 
-// readDirBulk opens the directory at dirPath and enumerates its entries using
-// GetFileInformationByHandleEx. It first attempts to use the file-ID based
-// information class. If that fails with ERROR_INVALID_PARAMETER, it falls
-// back to the full-directory information class. The entries that match
-// skipPathWithAttributes (and the "." and ".." names) are omitted.
 func readDirBulk(dirPath string) ([]byte, error) {
 	pDir, err := windows.UTF16PtrFromString(dirPath)
 	if err != nil {
@@ -189,11 +166,17 @@ func readDirBulk(dirPath string) ([]byte, error) {
 	}
 	defer windows.CloseHandle(handle)
 
-	const initialBufSize = 128 * 1024
-	// Allocate an initial slice with a capacity of 128 KB.
-	buf := make([]byte, initialBufSize)
+	bufPtr := bufPool.Get().(*[]byte)
+	buf := *bufPtr
+	defer func() {
+		if cap(buf) == cap(*bufPtr) {
+			bufPool.Put(bufPtr)
+		}
+	}()
 
 	var entries types.ReadDirEntries
+	entries = make([]types.AgentDirEntry, 0, 100) // Pre-allocate
+
 	usingFull := false
 	infoClass := windows.FileIdBothDirectoryInfo
 
@@ -205,80 +188,79 @@ func readDirBulk(dirPath string) ([]byte, error) {
 			uint32(len(buf)),
 		)
 		if err != nil {
-			var errno syscall.Errno
-			if errors.As(err, &errno) {
-				// If the buffer is too small, double its size and try again.
-				if errno == windows.ERROR_MORE_DATA {
-					newSize := len(buf) * 2
-					buf = make([]byte, newSize)
-					continue
-				}
-				// Fallback to using the full-directory information class if needed.
-				if errno == windows.ERROR_INVALID_PARAMETER && !usingFull {
-					infoClass = windows.FileFullDirectoryInfo
-					usingFull = true
-					continue
-				}
-				// When there are no more files, break out of the loop.
-				if errno == windows.ERROR_NO_MORE_FILES {
-					break
-				}
+			if err == windows.ERROR_MORE_DATA {
+				newBuf := make([]byte, len(buf)*2)
+				copy(newBuf, buf)
+				buf = newBuf
+				continue
+			}
+			if err == windows.ERROR_INVALID_PARAMETER && !usingFull {
+				infoClass = windows.FileFullDirectoryInfo
+				usingFull = true
+				continue
+			}
+			if err == windows.ERROR_NO_MORE_FILES {
+				break
 			}
 			return nil, mapWinError(err, "readDirBulk GetFileInformationByHandleEx")
 		}
 
-		// Process entries in the buffer.
 		offset := 0
 		for offset < len(buf) {
+			var name string
+			var attrs uint32
+
 			if usingFull {
-				// Use the FILE_FULL_DIR_INFO structure.
 				fullInfo := (*FILE_FULL_DIR_INFO)(unsafe.Pointer(&buf[offset]))
+				if fullInfo.NextEntryOffset == 0 && offset > 0 {
+					break
+				}
 				nameLen := int(fullInfo.FileNameLength) / 2
+				attrs = fullInfo.FileAttributes
 				if nameLen > 0 {
 					filenamePtr := fileNamePtrFull(fullInfo)
 					nameSlice := unsafe.Slice(filenamePtr, nameLen)
-					name := syscall.UTF16ToString(nameSlice)
-					if name != "." && name != ".." && fullInfo.FileAttributes&excludedAttrs == 0 {
-						isDir := (fullInfo.FileAttributes & windows.FILE_ATTRIBUTE_DIRECTORY) != 0
-
-						if fileIsAvailable(dirPath, name, isDir) {
-							mode := windowsAttributesToFileMode(fullInfo.FileAttributes)
-							entries = append(entries, types.AgentDirEntry{
-								Name: name,
-								Mode: mode,
-							})
-						}
+					if nameLen == 1 && nameSlice[0] == '.' {
+						offset += int(fullInfo.NextEntryOffset)
+						continue
 					}
-				}
-				if fullInfo.NextEntryOffset == 0 {
-					break
+					if nameLen == 2 && nameSlice[0] == '.' && nameSlice[1] == '.' {
+						offset += int(fullInfo.NextEntryOffset)
+						continue
+					}
+					name = syscall.UTF16ToString(nameSlice)
 				}
 				offset += int(fullInfo.NextEntryOffset)
 			} else {
-				// Use the FILE_ID_BOTH_DIR_INFO structure.
 				bothInfo := (*FILE_ID_BOTH_DIR_INFO)(unsafe.Pointer(&buf[offset]))
+				if bothInfo.NextEntryOffset == 0 && offset > 0 {
+					break
+				}
 				nameLen := int(bothInfo.FileNameLength) / 2
+				attrs = bothInfo.FileAttributes
 				if nameLen > 0 {
 					filenamePtr := fileNamePtrIdBoth(bothInfo)
 					nameSlice := unsafe.Slice(filenamePtr, nameLen)
-					name := syscall.UTF16ToString(nameSlice)
-					if name != "." && name != ".." && bothInfo.FileAttributes&excludedAttrs == 0 {
-						isDir := (bothInfo.FileAttributes & windows.FILE_ATTRIBUTE_DIRECTORY) != 0
-
-						if fileIsAvailable(dirPath, name, isDir) {
-							mode := windowsAttributesToFileMode(bothInfo.FileAttributes)
-							entries = append(entries, types.AgentDirEntry{
-								Name: name,
-								Mode: mode,
-							})
-						}
+					if nameLen == 1 && nameSlice[0] == '.' {
+						offset += int(bothInfo.NextEntryOffset)
+						continue
 					}
-				}
-				if bothInfo.NextEntryOffset == 0 {
-					break
+					if nameLen == 2 && nameSlice[0] == '.' && nameSlice[1] == '.' {
+						offset += int(bothInfo.NextEntryOffset)
+						continue
+					}
+					name = syscall.UTF16ToString(nameSlice)
 				}
 				offset += int(bothInfo.NextEntryOffset)
 			}
+
+			if name != "" && attrs&excludedAttrs == 0 {
+				mode := windowsAttributesToFileMode(attrs)
+				entries = append(entries, types.AgentDirEntry{
+					Name: name,
+					Mode: mode,
+				})
+			}
 		}
 	}
 
diff --git a/internal/backend/arpc/file.go b/internal/backend/arpc/file.go
index 19eb542..1e103f1 100644
--- a/internal/backend/arpc/file.go
+++ b/internal/backend/arpc/file.go
@@ -26,7 +26,7 @@ func (f *ARPCFile) Close() error {
 	}
 
 	req := types.CloseReq{HandleID: f.handleID}
-	_, err := f.fs.session.CallMsgWithTimeout(10*time.Second, f.jobId+"/Close", &req)
+	_, err := f.fs.session.CallMsgWithTimeout(1*time.Minute, f.jobId+"/Close", &req)
 	if err != nil && !errors.Is(err, os.ErrNotExist) {
 		syslog.L.Error(err).WithMessage("failed to handle close request").WithField("name", f.name).Write()
 		return err
@@ -43,7 +43,7 @@ func (f *ARPCFile) Lseek(off int64, whence int) (uint64, error) {
 		Whence:   whence,
 	}
 	// Send the request to the server
-	respBytes, err := f.fs.session.CallMsgWithTimeout(10*time.Second, f.jobId+"/Lseek", &req)
+	respBytes, err := f.fs.session.CallMsgWithTimeout(1*time.Minute, f.jobId+"/Lseek", &req)
 	if err != nil {
 		if arpc.IsOSError(err) {
 			return 0, err
diff --git a/internal/backend/arpc/fs.go b/internal/backend/arpc/fs.go
index b31bf60..773d178 100644
--- a/internal/backend/arpc/fs.go
+++ b/internal/backend/arpc/fs.go
@@ -133,8 +133,7 @@ func (fs *ARPCFS) OpenFile(filename string, flag int, perm os.FileMode) (ARPCFil
 		Perm: int(perm),
 	}
 
-	// Use the CPU efficient CallMsgDirect helper.
-	raw, err := fs.session.CallMsgWithTimeout(10*time.Second, fs.JobId+"/OpenFile", &req)
+	raw, err := fs.session.CallMsgWithTimeout(1*time.Minute, fs.JobId+"/OpenFile", &req)
 	if err != nil {
 		if arpc.IsOSError(err) {
 			return ARPCFile{}, err
@@ -164,7 +163,7 @@ func (fs *ARPCFS) Attr(filename string) (types.AgentFileInfo, error) {
 	}
 
 	req := types.StatReq{Path: filename}
-	raw, err := fs.session.CallMsgWithTimeout(time.Second*10, fs.JobId+"/Attr", &req)
+	raw, err := fs.session.CallMsgWithTimeout(1*time.Minute, fs.JobId+"/Attr", &req)
 	if err != nil {
 		if arpc.IsOSError(err) {
 			return types.AgentFileInfo{}, err
@@ -218,7 +217,7 @@ func (fs *ARPCFS) StatFS() (types.StatFS, error) {
 	}
 
 	var fsStat types.StatFS
-	raw, err := fs.session.CallMsgWithTimeout(10*time.Second, fs.JobId+"/StatFS", nil)
+	raw, err := fs.session.CallMsgWithTimeout(1*time.Minute, fs.JobId+"/StatFS", nil)
 	if err != nil {
 		syslog.L.Error(err).WithMessage("failed to handle statfs").Write()
 		if arpc.IsOSError(err) {
@@ -245,7 +244,7 @@ func (fs *ARPCFS) ReadDir(path string) (types.ReadDirEntries, error) {
 
 	var resp types.ReadDirEntries
 	req := types.ReadDirReq{Path: path}
-	raw, err := fs.session.CallMsgWithTimeout(10*time.Second, fs.JobId+"/ReadDir", &req)
+	raw, err := fs.session.CallMsgWithTimeout(1*time.Minute, fs.JobId+"/ReadDir", &req)
 	if err != nil {
 		if arpc.IsOSError(err) {
 			return nil, err
diff --git a/internal/backend/arpc/fuse/fuse.go b/internal/backend/arpc/fuse/fuse.go
index dc7cb5c..f40c1fc 100644
--- a/internal/backend/arpc/fuse/fuse.go
+++ b/internal/backend/arpc/fuse/fuse.go
@@ -30,7 +30,7 @@ func Mount(mountpoint string, fsName string, afs *arpcfs.ARPCFS) (*fuse.Server,
 
 	timeout := time.Hour * 24 * 365
 	if afs.GetBackupMode() == "direct" {
-		timeout = time.Second
+		timeout = 1 * time.Minute
 	}
 
 	options := &fs.Options{
