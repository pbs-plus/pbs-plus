//go:build linux

package proxmox

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/pbs-plus/pbs-plus/internal/store/constants"
	"github.com/pbs-plus/pbs-plus/internal/syslog"
)

type Token struct {
	CSRFToken string `json:"CSRFPreventionToken"`
	Ticket    string `json:"ticket"`
	Username  string `json:"username"`
}

type TokenResponse struct {
	Data Token `json:"data"`
}

type TokenRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type APITokenRequest struct {
	Comment string `json:"comment"`
}

type APITokenResponse struct {
	Data APIToken `json:"data"`
}

type ACLRequest struct {
	Path   string `json:"path"`
	Role   string `json:"role"`
	AuthId string `json:"auth-id"`
}

type APIToken struct {
	TokenId string `json:"tokenid"`
	Value   string `json:"value"`
}

const AUTH_USER = "plus-user@pbs"
const AUTH_TOKEN = "server"
const AUTH_ID = AUTH_USER + "!" + AUTH_TOKEN

func init() {
	createAPIToken()
}

func runCommandAndIgnoreExists(cmd *exec.Cmd, alreadyExistsKeywords []string) error {
	cmd.Env = os.Environ()
	outputBytes, err := cmd.CombinedOutput()
	outputStr := string(outputBytes)

	if err != nil {
		isAlreadyExistsError := false
		if len(alreadyExistsKeywords) > 0 {
			for _, keyword := range alreadyExistsKeywords {
				if strings.Contains(outputStr, keyword) {
					isAlreadyExistsError = true
					syslog.L.Info().WithMessage("Resource already exists (ignored error): " + cmd.String() + " - Output: " + outputStr).Write()
					break
				}
			}
		}

		if !isAlreadyExistsError {
			syslog.L.Error(err).WithMessage("Command failed: " + cmd.String() + " - Output: " + outputStr).Write()
			return err
		}
	}
	return nil
}

func extractJsonFromResult(output string) string {
	startIndex := strings.Index(output, "{")
	if startIndex == -1 {
		return ""
	}

	endIndex := strings.LastIndex(output, "}")
	if endIndex == -1 || endIndex < startIndex {
		return ""
	}
	return output[startIndex : endIndex+1]
}

func GetToken() string {
	token, err := getAPITokenFromFile()
	if err != nil {
		token, err = createAPIToken()
		if err == nil {
			_ = token.saveToFile()
		}
	}

	if token != nil {
		return token.Value
	}

	return ""
}

func createAPIToken() (*APIToken, error) {
	var cmdErr error
	var finalToken *APIToken

	cmdUserCreate := exec.Command(
		"proxmox-backup-manager",
		"user",
		"create",
		AUTH_USER,
		"--comment",
		"Autogenerated user for PBS Plus",
		"--firstname",
		"PBS",
		"--lastname",
		"Plus",
	)
	if err := runCommandAndIgnoreExists(cmdUserCreate, []string{"user '" + AUTH_USER + "' already exists"}); err != nil {
		return nil, err
	}

	cmdAclUser := exec.Command(
		"proxmox-backup-manager",
		"acl",
		"update",
		"/",
		"Admin",
		"--auth-id",
		AUTH_USER,
		"--propagate",
		"true",
	)
	if err := runCommandAndIgnoreExists(cmdAclUser, []string{"entry '" + AUTH_USER + "' already exists"}); err != nil {
		return nil, err
	}

	generateTokenCmd := func() *exec.Cmd {
		return exec.Command(
			"proxmox-backup-manager",
			"user",
			"generate-token",
			AUTH_USER,
			AUTH_TOKEN,
			"--comment",
			"Autogenerated API Token for PBS Plus",
		)
	}

	processTokenGeneration := func(rawOutput string) (*APIToken, error) {
		jsonStr := extractJsonFromResult(rawOutput)
		if jsonStr == "" {
			err := fmt.Errorf("could not extract JSON from token generation output")
			syslog.L.Error(err).WithMessage("Output was: " + rawOutput).Write()
			return nil, err
		}

		var details APIToken
		if err := json.Unmarshal([]byte(jsonStr), &details); err != nil {
			syslog.L.Error(err).WithMessage("Failed to parse token JSON: " + jsonStr).Write()
			return nil, fmt.Errorf("failed to parse token JSON: %w", err)
		}
		if details.Value == "" {
			err := fmt.Errorf("token value is empty after parsing JSON")
			syslog.L.Error(err).WithMessage("Parsed JSON: " + jsonStr).Write()
			return nil, err
		}
		return &details, nil
	}

	cmd := generateTokenCmd()
	cmd.Env = os.Environ()
	outputBytes, cmdErr := cmd.CombinedOutput()
	rawOutputStr := string(outputBytes)

	if cmdErr != nil {
		alreadyExistsTokenMsg := "token '" + AUTH_TOKEN + "' for user '" + AUTH_USER + "' already exists"
		if strings.Contains(rawOutputStr, alreadyExistsTokenMsg) {
			syslog.L.Info().WithMessage("Token " + AUTH_ID + " already exists. Attempting to delete and regenerate.").Write()

			cmdTokenDelete := exec.Command(
				"proxmox-backup-manager",
				"user",
				"delete-token",
				AUTH_USER,
				AUTH_TOKEN,
			)
			cmdTokenDelete.Env = os.Environ()
			deleteOutputBytes, deleteErr := cmdTokenDelete.CombinedOutput()
			deleteOutputStr := string(deleteOutputBytes)

			if deleteErr != nil {
				syslog.L.Error(deleteErr).WithMessage("Failed to delete existing token '" + AUTH_ID + "'. Output: " + deleteOutputStr).Write()
			} else {
				syslog.L.Info().WithMessage("Successfully deleted existing token: " + AUTH_ID + ". Output: " + deleteOutputStr).Write()
			}

			syslog.L.Info().WithMessage("Retrying token generation for: " + AUTH_ID).Write()
			cmdRetry := generateTokenCmd()
			cmdRetry.Env = os.Environ()
			outputBytesRetry, cmdErrRetry := cmdRetry.CombinedOutput()
			rawOutputStrRetry := string(outputBytesRetry)

			if cmdErrRetry != nil {
				syslog.L.Error(cmdErrRetry).WithMessage("Failed to generate token on retry for '" + AUTH_ID + "'. Output: " + rawOutputStrRetry).Write()
				return nil, cmdErrRetry
			}
			syslog.L.Info().WithMessage("Successfully generated token on retry for " + AUTH_ID + ".").Write()
			var parseErr error
			finalToken, parseErr = processTokenGeneration(rawOutputStrRetry)
			if parseErr != nil {
				return nil, parseErr
			}
		} else {
			syslog.L.Error(cmdErr).WithMessage("Failed to generate token '" + AUTH_ID + "'. Output: " + rawOutputStr).Write()
			return nil, cmdErr
		}
	} else {
		syslog.L.Info().WithMessage("Successfully generated token on first try for " + AUTH_ID + ".").Write()
		var parseErr error
		finalToken, parseErr = processTokenGeneration(rawOutputStr)
		if parseErr != nil {
			return nil, parseErr
		}
	}

	cmdAclToken := exec.Command(
		"proxmox-backup-manager",
		"acl",
		"update",
		"/",
		"Admin",
		"--auth-id",
		AUTH_ID,
		"--propagate",
		"true",
	)
	if err := runCommandAndIgnoreExists(cmdAclToken, []string{"entry '" + AUTH_ID + "' already exists"}); err != nil {
		return nil, err
	}

	syslog.L.Info().WithMessage("User token creation process completed successfully.").Write()
	return finalToken, nil
}

func (token *APIToken) saveToFile() error {
	if token == nil {
		return nil
	}

	tokenFileContent, _ := json.Marshal(token)
	file, err := os.OpenFile(filepath.Join(constants.DbBasePath, "pbs-plus-token.json"), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(string(tokenFileContent))
	if err != nil {
		return err
	}

	return nil
}

func getAPITokenFromFile() (*APIToken, error) {
	jsonFile, err := os.Open(filepath.Join(constants.DbBasePath, "pbs-plus-token.json"))
	if err != nil {
		return nil, err
	}
	defer jsonFile.Close()

	byteValue, err := io.ReadAll(jsonFile)
	if err != nil {
		return nil, err
	}

	var result APIToken
	err = json.Unmarshal([]byte(byteValue), &result)
	if err != nil {
		return nil, err
	}

	return &result, nil
}
