// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: backups.sql

package sqlc

import (
	"context"
	"database/sql"
)

const backupExists = `-- name: BackupExists :one
SELECT 1 FROM backups WHERE id = ? LIMIT 1
`

func (q *Queries) BackupExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, backupExists, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createBackup = `-- name: CreateBackup :exec
INSERT INTO backups (
    id, store, mode, source_mode, read_mode, target, subpath, schedule, comment,
    notification_mode, namespace, current_pid, last_run_upid, last_successful_upid, 
    retry, retry_interval, max_dir_entries, pre_script, post_script, 
    include_xattr, legacy_xattr
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateBackupParams struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Mode               interface{}    `json:"mode"`
	SourceMode         interface{}    `json:"source_mode"`
	ReadMode           interface{}    `json:"read_mode"`
	Target             string         `json:"target"`
	Subpath            sql.NullString `json:"subpath"`
	Schedule           sql.NullString `json:"schedule"`
	Comment            sql.NullString `json:"comment"`
	NotificationMode   sql.NullString `json:"notification_mode"`
	Namespace          sql.NullString `json:"namespace"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	MaxDirEntries      sql.NullInt64  `json:"max_dir_entries"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	IncludeXattr       sql.NullInt64  `json:"include_xattr"`
	LegacyXattr        sql.NullInt64  `json:"legacy_xattr"`
}

func (q *Queries) CreateBackup(ctx context.Context, arg CreateBackupParams) error {
	_, err := q.db.ExecContext(ctx, createBackup,
		arg.ID,
		arg.Store,
		arg.Mode,
		arg.SourceMode,
		arg.ReadMode,
		arg.Target,
		arg.Subpath,
		arg.Schedule,
		arg.Comment,
		arg.NotificationMode,
		arg.Namespace,
		arg.CurrentPid,
		arg.LastRunUpid,
		arg.LastSuccessfulUpid,
		arg.Retry,
		arg.RetryInterval,
		arg.MaxDirEntries,
		arg.PreScript,
		arg.PostScript,
		arg.IncludeXattr,
		arg.LegacyXattr,
	)
	return err
}

const deleteBackup = `-- name: DeleteBackup :execrows
DELETE FROM backups WHERE id = ?
`

func (q *Queries) DeleteBackup(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBackup, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBackup = `-- name: GetBackup :one
SELECT
    j.id, j.store, j.mode, j.source_mode, j.read_mode, j.target, j.subpath, 
    j.schedule, j.comment, j.notification_mode, j.namespace, j.current_pid, 
    j.last_run_upid, j.last_successful_upid, j.retry, j.retry_interval, 
    j.max_dir_entries, j.pre_script, j.post_script, j.include_xattr, j.legacy_xattr,
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
    t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM backups j
LEFT JOIN targets t ON j.target = t.name
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
WHERE j.id = ?
LIMIT 1
`

type GetBackupRow struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Mode               interface{}    `json:"mode"`
	SourceMode         interface{}    `json:"source_mode"`
	ReadMode           interface{}    `json:"read_mode"`
	Target             string         `json:"target"`
	Subpath            sql.NullString `json:"subpath"`
	Schedule           sql.NullString `json:"schedule"`
	Comment            sql.NullString `json:"comment"`
	NotificationMode   sql.NullString `json:"notification_mode"`
	Namespace          sql.NullString `json:"namespace"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	MaxDirEntries      sql.NullInt64  `json:"max_dir_entries"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	IncludeXattr       sql.NullInt64  `json:"include_xattr"`
	LegacyXattr        sql.NullInt64  `json:"legacy_xattr"`
	Name               sql.NullString `json:"name"`
	Path               sql.NullString `json:"path"`
	AgentHost          sql.NullString `json:"agent_host"`
	VolumeID           sql.NullString `json:"volume_id"`
	VolumeType         sql.NullString `json:"volume_type"`
	VolumeName         sql.NullString `json:"volume_name"`
	VolumeFs           sql.NullString `json:"volume_fs"`
	VolumeTotalBytes   sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes    sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes    sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal        sql.NullString `json:"volume_total"`
	VolumeUsed         sql.NullString `json:"volume_used"`
	VolumeFree         sql.NullString `json:"volume_free"`
	MountScript        sql.NullString `json:"mount_script"`
	AgentName          sql.NullString `json:"agent_name"`
	AgentIp            sql.NullString `json:"agent_ip"`
	AgentAuth          sql.NullString `json:"agent_auth"`
	AgentTokenUsed     sql.NullString `json:"agent_token_used"`
	AgentOs            sql.NullString `json:"agent_os"`
}

func (q *Queries) GetBackup(ctx context.Context, id string) (GetBackupRow, error) {
	row := q.db.QueryRowContext(ctx, getBackup, id)
	var i GetBackupRow
	err := row.Scan(
		&i.ID,
		&i.Store,
		&i.Mode,
		&i.SourceMode,
		&i.ReadMode,
		&i.Target,
		&i.Subpath,
		&i.Schedule,
		&i.Comment,
		&i.NotificationMode,
		&i.Namespace,
		&i.CurrentPid,
		&i.LastRunUpid,
		&i.LastSuccessfulUpid,
		&i.Retry,
		&i.RetryInterval,
		&i.MaxDirEntries,
		&i.PreScript,
		&i.PostScript,
		&i.IncludeXattr,
		&i.LegacyXattr,
		&i.Name,
		&i.Path,
		&i.AgentHost,
		&i.VolumeID,
		&i.VolumeType,
		&i.VolumeName,
		&i.VolumeFs,
		&i.VolumeTotalBytes,
		&i.VolumeUsedBytes,
		&i.VolumeFreeBytes,
		&i.VolumeTotal,
		&i.VolumeUsed,
		&i.VolumeFree,
		&i.MountScript,
		&i.AgentName,
		&i.AgentIp,
		&i.AgentAuth,
		&i.AgentTokenUsed,
		&i.AgentOs,
	)
	return i, err
}

const listAllBackups = `-- name: ListAllBackups :many
SELECT
    j.id, j.store, j.mode, j.source_mode, j.read_mode, j.target, j.subpath, 
    j.schedule, j.comment, j.notification_mode, j.namespace, j.current_pid, 
    j.last_run_upid, j.last_successful_upid, j.retry, j.retry_interval, 
    j.max_dir_entries, j.pre_script, j.post_script, j.include_xattr, j.legacy_xattr,
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
    t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM backups j
LEFT JOIN targets t ON j.target = t.name
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
ORDER BY j.id
`

type ListAllBackupsRow struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Mode               interface{}    `json:"mode"`
	SourceMode         interface{}    `json:"source_mode"`
	ReadMode           interface{}    `json:"read_mode"`
	Target             string         `json:"target"`
	Subpath            sql.NullString `json:"subpath"`
	Schedule           sql.NullString `json:"schedule"`
	Comment            sql.NullString `json:"comment"`
	NotificationMode   sql.NullString `json:"notification_mode"`
	Namespace          sql.NullString `json:"namespace"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	MaxDirEntries      sql.NullInt64  `json:"max_dir_entries"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	IncludeXattr       sql.NullInt64  `json:"include_xattr"`
	LegacyXattr        sql.NullInt64  `json:"legacy_xattr"`
	Name               sql.NullString `json:"name"`
	Path               sql.NullString `json:"path"`
	AgentHost          sql.NullString `json:"agent_host"`
	VolumeID           sql.NullString `json:"volume_id"`
	VolumeType         sql.NullString `json:"volume_type"`
	VolumeName         sql.NullString `json:"volume_name"`
	VolumeFs           sql.NullString `json:"volume_fs"`
	VolumeTotalBytes   sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes    sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes    sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal        sql.NullString `json:"volume_total"`
	VolumeUsed         sql.NullString `json:"volume_used"`
	VolumeFree         sql.NullString `json:"volume_free"`
	MountScript        sql.NullString `json:"mount_script"`
	AgentName          sql.NullString `json:"agent_name"`
	AgentIp            sql.NullString `json:"agent_ip"`
	AgentAuth          sql.NullString `json:"agent_auth"`
	AgentTokenUsed     sql.NullString `json:"agent_token_used"`
	AgentOs            sql.NullString `json:"agent_os"`
}

func (q *Queries) ListAllBackups(ctx context.Context) ([]ListAllBackupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllBackups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllBackupsRow{}
	for rows.Next() {
		var i ListAllBackupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Store,
			&i.Mode,
			&i.SourceMode,
			&i.ReadMode,
			&i.Target,
			&i.Subpath,
			&i.Schedule,
			&i.Comment,
			&i.NotificationMode,
			&i.Namespace,
			&i.CurrentPid,
			&i.LastRunUpid,
			&i.LastSuccessfulUpid,
			&i.Retry,
			&i.RetryInterval,
			&i.MaxDirEntries,
			&i.PreScript,
			&i.PostScript,
			&i.IncludeXattr,
			&i.LegacyXattr,
			&i.Name,
			&i.Path,
			&i.AgentHost,
			&i.VolumeID,
			&i.VolumeType,
			&i.VolumeName,
			&i.VolumeFs,
			&i.VolumeTotalBytes,
			&i.VolumeUsedBytes,
			&i.VolumeFreeBytes,
			&i.VolumeTotal,
			&i.VolumeUsed,
			&i.VolumeFree,
			&i.MountScript,
			&i.AgentName,
			&i.AgentIp,
			&i.AgentAuth,
			&i.AgentTokenUsed,
			&i.AgentOs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueuedBackups = `-- name: ListQueuedBackups :many
SELECT
    j.id, j.store, j.mode, j.source_mode, j.read_mode, j.target, j.subpath, 
    j.schedule, j.comment, j.notification_mode, j.namespace, j.current_pid, 
    j.last_run_upid, j.last_successful_upid, j.retry, j.retry_interval, 
    j.max_dir_entries, j.pre_script, j.post_script, j.include_xattr, j.legacy_xattr,
    t.volume_used_bytes, t.mount_script
FROM backups j
LEFT JOIN targets t ON j.target = t.name
WHERE j.last_run_upid LIKE '%pbsplusgen-queue%'
ORDER BY j.id
`

type ListQueuedBackupsRow struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Mode               interface{}    `json:"mode"`
	SourceMode         interface{}    `json:"source_mode"`
	ReadMode           interface{}    `json:"read_mode"`
	Target             string         `json:"target"`
	Subpath            sql.NullString `json:"subpath"`
	Schedule           sql.NullString `json:"schedule"`
	Comment            sql.NullString `json:"comment"`
	NotificationMode   sql.NullString `json:"notification_mode"`
	Namespace          sql.NullString `json:"namespace"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	MaxDirEntries      sql.NullInt64  `json:"max_dir_entries"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	IncludeXattr       sql.NullInt64  `json:"include_xattr"`
	LegacyXattr        sql.NullInt64  `json:"legacy_xattr"`
	VolumeUsedBytes    sql.NullInt64  `json:"volume_used_bytes"`
	MountScript        sql.NullString `json:"mount_script"`
}

func (q *Queries) ListQueuedBackups(ctx context.Context) ([]ListQueuedBackupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listQueuedBackups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQueuedBackupsRow{}
	for rows.Next() {
		var i ListQueuedBackupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Store,
			&i.Mode,
			&i.SourceMode,
			&i.ReadMode,
			&i.Target,
			&i.Subpath,
			&i.Schedule,
			&i.Comment,
			&i.NotificationMode,
			&i.Namespace,
			&i.CurrentPid,
			&i.LastRunUpid,
			&i.LastSuccessfulUpid,
			&i.Retry,
			&i.RetryInterval,
			&i.MaxDirEntries,
			&i.PreScript,
			&i.PostScript,
			&i.IncludeXattr,
			&i.LegacyXattr,
			&i.VolumeUsedBytes,
			&i.MountScript,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBackup = `-- name: UpdateBackup :exec
UPDATE backups 
SET store = ?, mode = ?, source_mode = ?, read_mode = ?, target = ?,
    subpath = ?, schedule = ?, comment = ?, notification_mode = ?,
    namespace = ?, current_pid = ?, last_run_upid = ?, retry = ?,
    retry_interval = ?, last_successful_upid = ?, pre_script = ?, 
    post_script = ?, max_dir_entries = ?, include_xattr = ?, legacy_xattr = ?
WHERE id = ?
`

type UpdateBackupParams struct {
	Store              string         `json:"store"`
	Mode               interface{}    `json:"mode"`
	SourceMode         interface{}    `json:"source_mode"`
	ReadMode           interface{}    `json:"read_mode"`
	Target             string         `json:"target"`
	Subpath            sql.NullString `json:"subpath"`
	Schedule           sql.NullString `json:"schedule"`
	Comment            sql.NullString `json:"comment"`
	NotificationMode   sql.NullString `json:"notification_mode"`
	Namespace          sql.NullString `json:"namespace"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	MaxDirEntries      sql.NullInt64  `json:"max_dir_entries"`
	IncludeXattr       sql.NullInt64  `json:"include_xattr"`
	LegacyXattr        sql.NullInt64  `json:"legacy_xattr"`
	ID                 string         `json:"id"`
}

func (q *Queries) UpdateBackup(ctx context.Context, arg UpdateBackupParams) error {
	_, err := q.db.ExecContext(ctx, updateBackup,
		arg.Store,
		arg.Mode,
		arg.SourceMode,
		arg.ReadMode,
		arg.Target,
		arg.Subpath,
		arg.Schedule,
		arg.Comment,
		arg.NotificationMode,
		arg.Namespace,
		arg.CurrentPid,
		arg.LastRunUpid,
		arg.Retry,
		arg.RetryInterval,
		arg.LastSuccessfulUpid,
		arg.PreScript,
		arg.PostScript,
		arg.MaxDirEntries,
		arg.IncludeXattr,
		arg.LegacyXattr,
		arg.ID,
	)
	return err
}
