// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: restores.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createRestore = `-- name: CreateRestore :exec
INSERT INTO restores (
    id, store, namespace, snapshot, src_path, dest_target, dest_subpath, 
    comment, current_pid, last_run_upid, last_successful_upid, retry,
    retry_interval, pre_script, post_script
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateRestoreParams struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Namespace          sql.NullString `json:"namespace"`
	Snapshot           string         `json:"snapshot"`
	SrcPath            string         `json:"src_path"`
	DestTarget         string         `json:"dest_target"`
	DestSubpath        sql.NullString `json:"dest_subpath"`
	Comment            sql.NullString `json:"comment"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
}

func (q *Queries) CreateRestore(ctx context.Context, arg CreateRestoreParams) error {
	_, err := q.db.ExecContext(ctx, createRestore,
		arg.ID,
		arg.Store,
		arg.Namespace,
		arg.Snapshot,
		arg.SrcPath,
		arg.DestTarget,
		arg.DestSubpath,
		arg.Comment,
		arg.CurrentPid,
		arg.LastRunUpid,
		arg.LastSuccessfulUpid,
		arg.Retry,
		arg.RetryInterval,
		arg.PreScript,
		arg.PostScript,
	)
	return err
}

const deleteRestore = `-- name: DeleteRestore :execrows
DELETE FROM restores WHERE id = ?
`

func (q *Queries) DeleteRestore(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteRestore, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getRestore = `-- name: GetRestore :one
SELECT
    j.id, j.store, j.namespace, j.snapshot, j.src_path, j.dest_target, 
    j.dest_subpath, j.comment, j.current_pid, j.last_run_upid, 
    j.last_successful_upid, j.retry, j.retry_interval, j.pre_script, j.post_script,
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
    t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM restores j
LEFT JOIN targets t ON j.dest_target = t.name
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
WHERE j.id = ?
LIMIT 1
`

type GetRestoreRow struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Namespace          sql.NullString `json:"namespace"`
	Snapshot           string         `json:"snapshot"`
	SrcPath            string         `json:"src_path"`
	DestTarget         string         `json:"dest_target"`
	DestSubpath        sql.NullString `json:"dest_subpath"`
	Comment            sql.NullString `json:"comment"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	Name               sql.NullString `json:"name"`
	Path               sql.NullString `json:"path"`
	AgentHost          sql.NullString `json:"agent_host"`
	VolumeID           sql.NullString `json:"volume_id"`
	VolumeType         sql.NullString `json:"volume_type"`
	VolumeName         sql.NullString `json:"volume_name"`
	VolumeFs           sql.NullString `json:"volume_fs"`
	VolumeTotalBytes   sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes    sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes    sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal        sql.NullString `json:"volume_total"`
	VolumeUsed         sql.NullString `json:"volume_used"`
	VolumeFree         sql.NullString `json:"volume_free"`
	MountScript        sql.NullString `json:"mount_script"`
	AgentName          sql.NullString `json:"agent_name"`
	AgentIp            sql.NullString `json:"agent_ip"`
	AgentAuth          sql.NullString `json:"agent_auth"`
	AgentTokenUsed     sql.NullString `json:"agent_token_used"`
	AgentOs            sql.NullString `json:"agent_os"`
}

func (q *Queries) GetRestore(ctx context.Context, id string) (GetRestoreRow, error) {
	row := q.db.QueryRowContext(ctx, getRestore, id)
	var i GetRestoreRow
	err := row.Scan(
		&i.ID,
		&i.Store,
		&i.Namespace,
		&i.Snapshot,
		&i.SrcPath,
		&i.DestTarget,
		&i.DestSubpath,
		&i.Comment,
		&i.CurrentPid,
		&i.LastRunUpid,
		&i.LastSuccessfulUpid,
		&i.Retry,
		&i.RetryInterval,
		&i.PreScript,
		&i.PostScript,
		&i.Name,
		&i.Path,
		&i.AgentHost,
		&i.VolumeID,
		&i.VolumeType,
		&i.VolumeName,
		&i.VolumeFs,
		&i.VolumeTotalBytes,
		&i.VolumeUsedBytes,
		&i.VolumeFreeBytes,
		&i.VolumeTotal,
		&i.VolumeUsed,
		&i.VolumeFree,
		&i.MountScript,
		&i.AgentName,
		&i.AgentIp,
		&i.AgentAuth,
		&i.AgentTokenUsed,
		&i.AgentOs,
	)
	return i, err
}

const listAllRestores = `-- name: ListAllRestores :many
SELECT
    j.id, j.store, j.namespace, j.snapshot, j.src_path, j.dest_target, 
    j.dest_subpath, j.comment, j.current_pid, j.last_run_upid, 
    j.last_successful_upid, j.retry, j.retry_interval, j.pre_script, j.post_script,
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
    t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM restores j
LEFT JOIN targets t ON j.dest_target = t.name
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
ORDER BY j.id
`

type ListAllRestoresRow struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Namespace          sql.NullString `json:"namespace"`
	Snapshot           string         `json:"snapshot"`
	SrcPath            string         `json:"src_path"`
	DestTarget         string         `json:"dest_target"`
	DestSubpath        sql.NullString `json:"dest_subpath"`
	Comment            sql.NullString `json:"comment"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	Name               sql.NullString `json:"name"`
	Path               sql.NullString `json:"path"`
	AgentHost          sql.NullString `json:"agent_host"`
	VolumeID           sql.NullString `json:"volume_id"`
	VolumeType         sql.NullString `json:"volume_type"`
	VolumeName         sql.NullString `json:"volume_name"`
	VolumeFs           sql.NullString `json:"volume_fs"`
	VolumeTotalBytes   sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes    sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes    sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal        sql.NullString `json:"volume_total"`
	VolumeUsed         sql.NullString `json:"volume_used"`
	VolumeFree         sql.NullString `json:"volume_free"`
	MountScript        sql.NullString `json:"mount_script"`
	AgentName          sql.NullString `json:"agent_name"`
	AgentIp            sql.NullString `json:"agent_ip"`
	AgentAuth          sql.NullString `json:"agent_auth"`
	AgentTokenUsed     sql.NullString `json:"agent_token_used"`
	AgentOs            sql.NullString `json:"agent_os"`
}

func (q *Queries) ListAllRestores(ctx context.Context) ([]ListAllRestoresRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllRestores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllRestoresRow{}
	for rows.Next() {
		var i ListAllRestoresRow
		if err := rows.Scan(
			&i.ID,
			&i.Store,
			&i.Namespace,
			&i.Snapshot,
			&i.SrcPath,
			&i.DestTarget,
			&i.DestSubpath,
			&i.Comment,
			&i.CurrentPid,
			&i.LastRunUpid,
			&i.LastSuccessfulUpid,
			&i.Retry,
			&i.RetryInterval,
			&i.PreScript,
			&i.PostScript,
			&i.Name,
			&i.Path,
			&i.AgentHost,
			&i.VolumeID,
			&i.VolumeType,
			&i.VolumeName,
			&i.VolumeFs,
			&i.VolumeTotalBytes,
			&i.VolumeUsedBytes,
			&i.VolumeFreeBytes,
			&i.VolumeTotal,
			&i.VolumeUsed,
			&i.VolumeFree,
			&i.MountScript,
			&i.AgentName,
			&i.AgentIp,
			&i.AgentAuth,
			&i.AgentTokenUsed,
			&i.AgentOs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueuedRestores = `-- name: ListQueuedRestores :many
SELECT
    j.id, j.store, j.namespace, j.snapshot, j.src_path, j.dest_target, 
    j.dest_subpath, j.comment, j.current_pid, j.last_run_upid, 
    j.last_successful_upid, j.retry, j.retry_interval, j.pre_script, j.post_script
FROM restores j
LEFT JOIN targets t ON j.dest_target = t.name
WHERE j.last_run_upid LIKE '%pbsplusgen-queue%'
ORDER BY j.id
`

type ListQueuedRestoresRow struct {
	ID                 string         `json:"id"`
	Store              string         `json:"store"`
	Namespace          sql.NullString `json:"namespace"`
	Snapshot           string         `json:"snapshot"`
	SrcPath            string         `json:"src_path"`
	DestTarget         string         `json:"dest_target"`
	DestSubpath        sql.NullString `json:"dest_subpath"`
	Comment            sql.NullString `json:"comment"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
}

func (q *Queries) ListQueuedRestores(ctx context.Context) ([]ListQueuedRestoresRow, error) {
	rows, err := q.db.QueryContext(ctx, listQueuedRestores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQueuedRestoresRow{}
	for rows.Next() {
		var i ListQueuedRestoresRow
		if err := rows.Scan(
			&i.ID,
			&i.Store,
			&i.Namespace,
			&i.Snapshot,
			&i.SrcPath,
			&i.DestTarget,
			&i.DestSubpath,
			&i.Comment,
			&i.CurrentPid,
			&i.LastRunUpid,
			&i.LastSuccessfulUpid,
			&i.Retry,
			&i.RetryInterval,
			&i.PreScript,
			&i.PostScript,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreExists = `-- name: RestoreExists :one
SELECT 1 FROM restores WHERE id = ? LIMIT 1
`

func (q *Queries) RestoreExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, restoreExists, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateRestore = `-- name: UpdateRestore :exec
UPDATE restores 
SET store = ?, namespace = ?, snapshot = ?, src_path = ?, dest_target = ?, 
    dest_subpath = ?, comment = ?, current_pid = ?, last_run_upid = ?, 
    retry = ?, retry_interval = ?, last_successful_upid = ?, 
    pre_script = ?, post_script = ?
WHERE id = ?
`

type UpdateRestoreParams struct {
	Store              string         `json:"store"`
	Namespace          sql.NullString `json:"namespace"`
	Snapshot           string         `json:"snapshot"`
	SrcPath            string         `json:"src_path"`
	DestTarget         string         `json:"dest_target"`
	DestSubpath        sql.NullString `json:"dest_subpath"`
	Comment            sql.NullString `json:"comment"`
	CurrentPid         sql.NullString `json:"current_pid"`
	LastRunUpid        sql.NullString `json:"last_run_upid"`
	Retry              sql.NullInt64  `json:"retry"`
	RetryInterval      sql.NullInt64  `json:"retry_interval"`
	LastSuccessfulUpid sql.NullString `json:"last_successful_upid"`
	PreScript          string         `json:"pre_script"`
	PostScript         string         `json:"post_script"`
	ID                 string         `json:"id"`
}

func (q *Queries) UpdateRestore(ctx context.Context, arg UpdateRestoreParams) error {
	_, err := q.db.ExecContext(ctx, updateRestore,
		arg.Store,
		arg.Namespace,
		arg.Snapshot,
		arg.SrcPath,
		arg.DestTarget,
		arg.DestSubpath,
		arg.Comment,
		arg.CurrentPid,
		arg.LastRunUpid,
		arg.Retry,
		arg.RetryInterval,
		arg.LastSuccessfulUpid,
		arg.PreScript,
		arg.PostScript,
		arg.ID,
	)
	return err
}
