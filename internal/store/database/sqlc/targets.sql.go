// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: targets.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createTarget = `-- name: CreateTarget :exec
INSERT INTO targets (
    name, path, agent_host, volume_id, volume_type, volume_name, volume_fs,
    volume_total_bytes, volume_used_bytes, volume_free_bytes,
    volume_total, volume_used, volume_free, mount_script
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTargetParams struct {
	Name             string         `json:"name"`
	Path             string         `json:"path"`
	AgentHost        sql.NullString `json:"agent_host"`
	VolumeID         sql.NullString `json:"volume_id"`
	VolumeType       sql.NullString `json:"volume_type"`
	VolumeName       sql.NullString `json:"volume_name"`
	VolumeFs         sql.NullString `json:"volume_fs"`
	VolumeTotalBytes sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes  sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes  sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal      sql.NullString `json:"volume_total"`
	VolumeUsed       sql.NullString `json:"volume_used"`
	VolumeFree       sql.NullString `json:"volume_free"`
	MountScript      string         `json:"mount_script"`
}

func (q *Queries) CreateTarget(ctx context.Context, arg CreateTargetParams) error {
	_, err := q.db.ExecContext(ctx, createTarget,
		arg.Name,
		arg.Path,
		arg.AgentHost,
		arg.VolumeID,
		arg.VolumeType,
		arg.VolumeName,
		arg.VolumeFs,
		arg.VolumeTotalBytes,
		arg.VolumeUsedBytes,
		arg.VolumeFreeBytes,
		arg.VolumeTotal,
		arg.VolumeUsed,
		arg.VolumeFree,
		arg.MountScript,
	)
	return err
}

const deleteTarget = `-- name: DeleteTarget :execrows
DELETE FROM targets WHERE name = ?
`

func (q *Queries) DeleteTarget(ctx context.Context, name string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTarget, name)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getTarget = `-- name: GetTarget :one
SELECT
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
    t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    COUNT(j.id) as job_count,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM targets t
LEFT JOIN backups j ON t.name = j.target
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
WHERE t.name = ?
GROUP BY t.name
`

type GetTargetRow struct {
	Name             string         `json:"name"`
	Path             string         `json:"path"`
	AgentHost        sql.NullString `json:"agent_host"`
	VolumeID         sql.NullString `json:"volume_id"`
	VolumeType       sql.NullString `json:"volume_type"`
	VolumeName       sql.NullString `json:"volume_name"`
	VolumeFs         sql.NullString `json:"volume_fs"`
	VolumeTotalBytes sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes  sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes  sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal      sql.NullString `json:"volume_total"`
	VolumeUsed       sql.NullString `json:"volume_used"`
	VolumeFree       sql.NullString `json:"volume_free"`
	MountScript      string         `json:"mount_script"`
	JobCount         int64          `json:"job_count"`
	AgentName        sql.NullString `json:"agent_name"`
	AgentIp          sql.NullString `json:"agent_ip"`
	AgentAuth        sql.NullString `json:"agent_auth"`
	AgentTokenUsed   sql.NullString `json:"agent_token_used"`
	AgentOs          sql.NullString `json:"agent_os"`
}

func (q *Queries) GetTarget(ctx context.Context, name string) (GetTargetRow, error) {
	row := q.db.QueryRowContext(ctx, getTarget, name)
	var i GetTargetRow
	err := row.Scan(
		&i.Name,
		&i.Path,
		&i.AgentHost,
		&i.VolumeID,
		&i.VolumeType,
		&i.VolumeName,
		&i.VolumeFs,
		&i.VolumeTotalBytes,
		&i.VolumeUsedBytes,
		&i.VolumeFreeBytes,
		&i.VolumeTotal,
		&i.VolumeUsed,
		&i.VolumeFree,
		&i.MountScript,
		&i.JobCount,
		&i.AgentName,
		&i.AgentIp,
		&i.AgentAuth,
		&i.AgentTokenUsed,
		&i.AgentOs,
	)
	return i, err
}

const getTargetS3Secret = `-- name: GetTargetS3Secret :one
SELECT secret_s3 FROM targets WHERE name = ?
`

func (q *Queries) GetTargetS3Secret(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTargetS3Secret, name)
	var secret_s3 string
	err := row.Scan(&secret_s3)
	return secret_s3, err
}

const listAllTargets = `-- name: ListAllTargets :many
SELECT
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
    t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    COUNT(j.id) as job_count,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM targets t
LEFT JOIN backups j ON t.name = j.target
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
GROUP BY t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name,
         t.volume_fs, t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
         t.volume_total, t.volume_used, t.volume_free, t.mount_script,
         ah.name, ah.ip, ah.auth, ah.token_used, ah.os
ORDER BY t.name
`

type ListAllTargetsRow struct {
	Name             string         `json:"name"`
	Path             string         `json:"path"`
	AgentHost        sql.NullString `json:"agent_host"`
	VolumeID         sql.NullString `json:"volume_id"`
	VolumeType       sql.NullString `json:"volume_type"`
	VolumeName       sql.NullString `json:"volume_name"`
	VolumeFs         sql.NullString `json:"volume_fs"`
	VolumeTotalBytes sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes  sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes  sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal      sql.NullString `json:"volume_total"`
	VolumeUsed       sql.NullString `json:"volume_used"`
	VolumeFree       sql.NullString `json:"volume_free"`
	MountScript      string         `json:"mount_script"`
	JobCount         int64          `json:"job_count"`
	AgentName        sql.NullString `json:"agent_name"`
	AgentIp          sql.NullString `json:"agent_ip"`
	AgentAuth        sql.NullString `json:"agent_auth"`
	AgentTokenUsed   sql.NullString `json:"agent_token_used"`
	AgentOs          sql.NullString `json:"agent_os"`
}

func (q *Queries) ListAllTargets(ctx context.Context) ([]ListAllTargetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllTargets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllTargetsRow{}
	for rows.Next() {
		var i ListAllTargetsRow
		if err := rows.Scan(
			&i.Name,
			&i.Path,
			&i.AgentHost,
			&i.VolumeID,
			&i.VolumeType,
			&i.VolumeName,
			&i.VolumeFs,
			&i.VolumeTotalBytes,
			&i.VolumeUsedBytes,
			&i.VolumeFreeBytes,
			&i.VolumeTotal,
			&i.VolumeUsed,
			&i.VolumeFree,
			&i.MountScript,
			&i.JobCount,
			&i.AgentName,
			&i.AgentIp,
			&i.AgentAuth,
			&i.AgentTokenUsed,
			&i.AgentOs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTargetsByAgentHost = `-- name: ListTargetsByAgentHost :many
SELECT 
    t.name, t.path, t.agent_host, t.volume_id, t.volume_type, t.volume_name, t.volume_fs,
    t.volume_total_bytes, t.volume_used_bytes, t.volume_free_bytes,
    t.volume_total, t.volume_used, t.volume_free, t.mount_script,
    ah.name as agent_name, ah.ip as agent_ip, ah.auth as agent_auth, 
    ah.token_used as agent_token_used, ah.os as agent_os
FROM targets t
LEFT JOIN agent_hosts ah ON t.agent_host = ah.name
WHERE t.agent_host = ?
ORDER BY t.name
`

type ListTargetsByAgentHostRow struct {
	Name             string         `json:"name"`
	Path             string         `json:"path"`
	AgentHost        sql.NullString `json:"agent_host"`
	VolumeID         sql.NullString `json:"volume_id"`
	VolumeType       sql.NullString `json:"volume_type"`
	VolumeName       sql.NullString `json:"volume_name"`
	VolumeFs         sql.NullString `json:"volume_fs"`
	VolumeTotalBytes sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes  sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes  sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal      sql.NullString `json:"volume_total"`
	VolumeUsed       sql.NullString `json:"volume_used"`
	VolumeFree       sql.NullString `json:"volume_free"`
	MountScript      string         `json:"mount_script"`
	AgentName        sql.NullString `json:"agent_name"`
	AgentIp          sql.NullString `json:"agent_ip"`
	AgentAuth        sql.NullString `json:"agent_auth"`
	AgentTokenUsed   sql.NullString `json:"agent_token_used"`
	AgentOs          sql.NullString `json:"agent_os"`
}

func (q *Queries) ListTargetsByAgentHost(ctx context.Context, agentHost sql.NullString) ([]ListTargetsByAgentHostRow, error) {
	rows, err := q.db.QueryContext(ctx, listTargetsByAgentHost, agentHost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTargetsByAgentHostRow{}
	for rows.Next() {
		var i ListTargetsByAgentHostRow
		if err := rows.Scan(
			&i.Name,
			&i.Path,
			&i.AgentHost,
			&i.VolumeID,
			&i.VolumeType,
			&i.VolumeName,
			&i.VolumeFs,
			&i.VolumeTotalBytes,
			&i.VolumeUsedBytes,
			&i.VolumeFreeBytes,
			&i.VolumeTotal,
			&i.VolumeUsed,
			&i.VolumeFree,
			&i.MountScript,
			&i.AgentName,
			&i.AgentIp,
			&i.AgentAuth,
			&i.AgentTokenUsed,
			&i.AgentOs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const targetExists = `-- name: TargetExists :one
SELECT 1 FROM targets WHERE name = ? LIMIT 1
`

func (q *Queries) TargetExists(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, targetExists, name)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateTarget = `-- name: UpdateTarget :exec
UPDATE targets SET
    path = ?, agent_host = ?, volume_id = ?, volume_type = ?,
    volume_name = ?, volume_fs = ?, volume_total_bytes = ?,
    volume_used_bytes = ?, volume_free_bytes = ?, volume_total = ?,
    volume_used = ?, volume_free = ?, mount_script = ?
WHERE name = ?
`

type UpdateTargetParams struct {
	Path             string         `json:"path"`
	AgentHost        sql.NullString `json:"agent_host"`
	VolumeID         sql.NullString `json:"volume_id"`
	VolumeType       sql.NullString `json:"volume_type"`
	VolumeName       sql.NullString `json:"volume_name"`
	VolumeFs         sql.NullString `json:"volume_fs"`
	VolumeTotalBytes sql.NullInt64  `json:"volume_total_bytes"`
	VolumeUsedBytes  sql.NullInt64  `json:"volume_used_bytes"`
	VolumeFreeBytes  sql.NullInt64  `json:"volume_free_bytes"`
	VolumeTotal      sql.NullString `json:"volume_total"`
	VolumeUsed       sql.NullString `json:"volume_used"`
	VolumeFree       sql.NullString `json:"volume_free"`
	MountScript      string         `json:"mount_script"`
	Name             string         `json:"name"`
}

func (q *Queries) UpdateTarget(ctx context.Context, arg UpdateTargetParams) error {
	_, err := q.db.ExecContext(ctx, updateTarget,
		arg.Path,
		arg.AgentHost,
		arg.VolumeID,
		arg.VolumeType,
		arg.VolumeName,
		arg.VolumeFs,
		arg.VolumeTotalBytes,
		arg.VolumeUsedBytes,
		arg.VolumeFreeBytes,
		arg.VolumeTotal,
		arg.VolumeUsed,
		arg.VolumeFree,
		arg.MountScript,
		arg.Name,
	)
	return err
}

const updateTargetS3Secret = `-- name: UpdateTargetS3Secret :exec
UPDATE targets SET secret_s3 = ? WHERE name = ?
`

type UpdateTargetS3SecretParams struct {
	SecretS3 string `json:"secret_s3"`
	Name     string `json:"name"`
}

func (q *Queries) UpdateTargetS3Secret(ctx context.Context, arg UpdateTargetS3SecretParams) error {
	_, err := q.db.ExecContext(ctx, updateTargetS3Secret, arg.SecretS3, arg.Name)
	return err
}
