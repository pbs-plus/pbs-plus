#!/bin/sh
set -e

# Config (can be overridden by env)
SERVICE_NAME="${SERVICE_NAME:-pbs-plus-agent}"
BIN_PATH="${BIN_PATH:-/usr/bin/pbs-plus-agent}"

STATE_DIR="${STATE_DIR:-/var/lib/pbs-plus-agent}"
LOG_DIR="${LOG_DIR:-/var/log/pbs-plus-agent}"
RUN_DIR="${RUN_DIR:-/run/pbs-plus-agent}"
ETC_DIR="${ETC_DIR:-/etc/pbs-plus-agent}"

CAP_PROFILE="${CAP_PROFILE:-tight}"          # tight|broad
ENABLE_LINGER="${ENABLE_LINGER:-true}"       # true|false
ENABLE_SELINUX_HELPERS="${ENABLE_SELINUX_HELPERS:-false}"

# Helper functions
is_cmd() { command -v "$1" >/dev/null 2>&1; }

log() { echo "$@"; }
warn() { echo "Warning: $@" >&2; }

# Detect OS and init system
detect_system() {
  ID_LIKE=""
  ID=""
  if [ -r /etc/os-release ]; then
    # shellcheck disable=SC1091
    . /etc/os-release
  fi

  is_systemd=false
  is_openrc=false

  if is_cmd systemctl && systemctl >/dev/null 2>&1; then
    is_systemd=true
  fi

  if is_cmd rc-update && is_cmd rc-service; then
    is_openrc=true
  fi
}

# Create group if missing
create_group() {
  if getent group pbsplus >/dev/null 2>&1; then
    return 0
  fi

  if is_cmd addgroup; then
    # BusyBox/Alpine style
    addgroup -S pbsplus 2>/dev/null || addgroup pbsplus
  elif is_cmd groupadd; then
    # GNU shadow-utils
    groupadd -r pbsplus
  else
    warn "No group creation command found"
    return 1
  fi
  log "Created group: pbsplus"
}

# Create user if missing
create_user() {
  if getent passwd pbsplus >/dev/null 2>&1; then
    return 0
  fi

  # Determine shell path
  NOLOGIN_SHELL="/sbin/nologin"
  if [ ! -x "$NOLOGIN_SHELL" ]; then
    NOLOGIN_SHELL="/usr/sbin/nologin"
  fi
  if [ ! -x "$NOLOGIN_SHELL" ]; then
    NOLOGIN_SHELL="/bin/false"
  fi

  if is_cmd adduser; then
    # BusyBox/Alpine style
    adduser -S -D -H -s "$NOLOGIN_SHELL" \
      -h "$STATE_DIR" -G pbsplus \
      -g "PBS Plus Agent" pbsplus 2>/dev/null || \
    adduser -S -D -s "$NOLOGIN_SHELL" \
      -h "$STATE_DIR" pbsplus
  elif is_cmd useradd; then
    # GNU shadow-utils
    useradd -r -g pbsplus -s "$NOLOGIN_SHELL" \
      -d "$STATE_DIR" -c "PBS Plus Agent" pbsplus
  else
    warn "No user creation command found"
    return 1
  fi
  log "Created user: pbsplus"
}

# Set binary permissions
setup_binary() {
  if [ ! -e "$BIN_PATH" ]; then
    warn "$BIN_PATH not found - capabilities will not be set"
    return 0
  fi

  chmod 0755 "$BIN_PATH"
  chown root:pbsplus "$BIN_PATH" 2>/dev/null || chown root:root "$BIN_PATH"
  log "Set permissions on $BIN_PATH"
}

# Create directories
create_directories() {
  mkdir -p "$STATE_DIR" "$LOG_DIR" "$RUN_DIR" "$ETC_DIR"
  
  chown -R pbsplus:pbsplus "$STATE_DIR" "$LOG_DIR" "$RUN_DIR" "$ETC_DIR"
  
  chmod 0750 "$STATE_DIR"
  chmod 0750 "$LOG_DIR"
  chmod 0755 "$RUN_DIR"
  chmod 0750 "$ETC_DIR"
  
  log "Created and configured directories"
}

# Add user to system groups for broad read access
add_to_groups() {
  # Comprehensive list of groups that may grant read access
  groups_list="wheel disk adm sys tty audio video netdev kvm qemu docker \
    lp dialout tape staff shadow systemd-journal ssl-cert libvirt lvm \
    users backup cdrom floppy scanner games mail"

  added_count=0
  for group in $groups_list; do
    if getent group "$group" >/dev/null 2>&1; then
      if is_cmd usermod; then
        # GNU usermod
        usermod -a -G "$group" pbsplus 2>/dev/null && added_count=$((added_count + 1))
      elif is_cmd adduser; then
        # BusyBox adduser (Alpine)
        adduser pbsplus "$group" 2>/dev/null && added_count=$((added_count + 1))
      fi
    fi
  done
  
  log "Added pbsplus to $added_count system groups"
}

# Set Linux capabilities for filesystem access
set_capabilities() {
  if ! is_cmd setcap; then
    warn "setcap not available - install libcap for capability support"
    return 0
  fi

  if [ ! -e "$BIN_PATH" ]; then
    return 0
  fi

  # Tight profile: minimal for read-only backup access
  # - cap_dac_read_search: bypass read permission checks
  # - cap_dac_override: bypass all DAC checks (read, write, execute)
  tight_caps="cap_dac_read_search,cap_dac_override+ep"

  # Broad profile: additional capabilities for special files/devices
  # - cap_fowner: bypass permission checks for operations that require file owner
  # - cap_sys_admin: various admin operations (mount info, etc)
  # - cap_sys_ptrace: read /proc/<pid> for other users
  # - cap_sys_rawio: raw block device access
  # - cap_mknod: not typically needed for read-only, but included
  broad_caps="cap_dac_read_search,cap_dac_override,cap_fowner,cap_sys_admin,cap_sys_ptrace,cap_sys_rawio,cap_mknod+ep"

  case "$CAP_PROFILE" in
    broad)
      setcap "$broad_caps" "$BIN_PATH"
      log "Set broad capabilities on $BIN_PATH"
      ;;
    tight|*)
      setcap "$tight_caps" "$BIN_PATH"
      log "Set tight capabilities on $BIN_PATH"
      ;;
  esac

  if is_cmd getcap; then
    getcap "$BIN_PATH"
  fi
}

# Configure PAM limits for heavy I/O operations
set_pam_limits() {
  limits_file="/etc/security/limits.conf"
  
  if [ ! -w "$limits_file" ]; then
    return 0
  fi

  if grep -q '^pbsplus ' "$limits_file" 2>/dev/null; then
    return 0
  fi

  cat >> "$limits_file" <<'EOF'
pbsplus soft nofile 65536
pbsplus hard nofile 65536
pbsplus soft nproc 32768
pbsplus hard nproc 32768
EOF
  log "Configured PAM limits"
}

# Enable systemd lingering
enable_lingering() {
  if [ "$ENABLE_LINGER" != "true" ]; then
    return 0
  fi

  if is_cmd loginctl; then
    loginctl enable-linger pbsplus 2>/dev/null || true
    log "Enabled lingering for pbsplus"
  fi
}

# Check for LSM and provide guidance
check_security_modules() {
  # AppArmor
  if is_cmd aa-status && aa-status --enabled >/dev/null 2>&1; then
    log "AppArmor detected - you may need to configure profiles for $BIN_PATH"
    log "  Consider creating a profile allowing read access to all paths"
  fi

  # SELinux
  if is_cmd getenforce; then
    selinux_status=$(getenforce 2>/dev/null || echo "Disabled")
    if [ "$selinux_status" != "Disabled" ]; then
      log "SELinux is $selinux_status"
      log "  You may need to configure policies for $BIN_PATH"
      log "  Monitor denials: ausearch -m avc -ts recent"
      
      if [ "$ENABLE_SELINUX_HELPERS" = "true" ] && is_cmd semanage; then
        # Basic SELinux context - site-specific tuning recommended
        semanage fcontext -a -t bin_t "$BIN_PATH" 2>/dev/null || true
        restorecon -v "$BIN_PATH" 2>/dev/null || true
        log "Applied basic SELinux context"
      fi
    fi
  fi
}

# Setup and start service
setup_service() {
  if $is_systemd; then
    systemctl daemon-reload 2>/dev/null || true
    
    # Check if service file exists
    if systemctl list-unit-files 2>/dev/null | grep -q "^$SERVICE_NAME.service"; then
      systemctl enable "$SERVICE_NAME.service" 2>/dev/null || true
      systemctl restart "$SERVICE_NAME.service" 2>/dev/null || true
      log "Systemd service $SERVICE_NAME enabled and started"
      log "  Check status: systemctl status $SERVICE_NAME.service"
    else
      warn "Service file $SERVICE_NAME.service not found - manual setup required"
    fi
  elif $is_openrc; then
    if [ -x "/etc/init.d/$SERVICE_NAME" ]; then
      rc-update add "$SERVICE_NAME" default 2>/dev/null || true
      rc-service "$SERVICE_NAME" restart 2>/dev/null || \
        rc-service "$SERVICE_NAME" start 2>/dev/null || true
      log "OpenRC service $SERVICE_NAME enabled and started"
      log "  Check status: rc-service $SERVICE_NAME status"
    else
      warn "Init script /etc/init.d/$SERVICE_NAME not found - manual setup required"
    fi
  else
    warn "Unknown init system - please enable $SERVICE_NAME manually"
  fi
}

# Display final status
show_status() {
  log ""
  log "========================================="
  log "PBS Plus Agent Installation Complete"
  log "========================================="
  log ""
  log "User: pbsplus"
  log "Groups: $(groups pbsplus 2>/dev/null || echo 'N/A')"
  log ""
  
  if is_cmd getcap && [ -e "$BIN_PATH" ]; then
    log "Capabilities: $(getcap "$BIN_PATH" 2>/dev/null || echo 'N/A')"
  fi
  
  log ""
  log "Service: $SERVICE_NAME"
  if $is_systemd; then
    log "  Status: systemctl status $SERVICE_NAME"
    log "  Logs:   journalctl -u $SERVICE_NAME -f"
  elif $is_openrc; then
    log "  Status: rc-service $SERVICE_NAME status"
    log "  Logs:   tail -f $LOG_DIR/*.log"
  fi
  log ""
  log "Note: The pbsplus user has read-only access to system files"
  log "      via capabilities and group memberships."
  log ""
}

# Main execution
main() {
  log "Starting PBS Plus Agent setup..."
  
  detect_system
  create_group
  create_user
  setup_binary
  create_directories
  add_to_groups
  set_capabilities
  set_pam_limits
  enable_lingering
  check_security_modules
  setup_service
  show_status
}

main
